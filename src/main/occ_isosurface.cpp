#include <chrono>
#include <filesystem>
#include <fmt/os.h>
#include <fmt/ostream.h>
#include <occ/core/kdtree.h>
#include <occ/core/linear_algebra.h>
#include <occ/core/log.h>
#include <occ/core/numpy.h>
#include <occ/core/timings.h>
#include <occ/core/units.h>
#include <occ/geometry/marching_cubes.h>
#include <occ/io/xyz.h>
#include <occ/io/obj.h>
#include <occ/io/ply.h>
#include <occ/io/tinyply.h>
#include <occ/main/isosurface.h>
#include <occ/main/occ_isosurface.h>

namespace fs = std::filesystem;
using occ::IVec;
using occ::Mat3N;
using occ::Vec3;
using occ::core::Element;
using occ::core::Interpolator1D;
using occ::core::Molecule;
using occ::main::PromoleculeDensityFunctor;
using occ::main::StockholderWeightFunctor;
using occ::io::IsosurfaceMesh;
using occ::io::VertexProperties;


void write_mesh_file(const std::string &filename, const IsosurfaceMesh &mesh,
		     const VertexProperties &properties, bool binary = true) {


    tinyply::PlyFile ply_file;

    ply_file.add_properties_to_element("vertex", { "x", "y", "z" }, 
        tinyply::Type::FLOAT32, mesh.vertices.size() / 3,
	reinterpret_cast<const uint8_t*>(mesh.vertices.data()), tinyply::Type::INVALID, 0);

    ply_file.add_properties_to_element("vertex", { "nx", "ny", "nz" },
        tinyply::Type::FLOAT32, mesh.normals.size() / 3,
	reinterpret_cast<const uint8_t*>(mesh.normals.data()), tinyply::Type::INVALID, 0);

    ply_file.add_properties_to_element("face", { "vertex_indices" },
        tinyply::Type::UINT32, mesh.faces.size() / 3, 
	reinterpret_cast<const uint8_t*>(mesh.faces.data()), tinyply::Type::UINT32, 3);

    for(const auto &[k, v]: properties.fprops) {
	ply_file.add_properties_to_element("vertex", {k},
	    tinyply::Type::FLOAT32, v.size(),
	    reinterpret_cast<const uint8_t*>(v.data()), tinyply::Type::INVALID, 0);
    }

    for(const auto &[k, v]: properties.iprops) {
	ply_file.add_properties_to_element("vertex", {k},
	    tinyply::Type::INT32, v.size(),
	    reinterpret_cast<const uint8_t*>(v.data()), tinyply::Type::INVALID, 0);
    }


    ply_file.get_comments().push_back("Generated by OCC");

    std::filebuf out_fb;
    if(binary) {
	out_fb.open(filename, std::ios::out | std::ios::binary);
    } else {
	out_fb.open(filename, std::ios::out);
    }
    std::ostream out(&out_fb);
    if (out.fail()) throw std::runtime_error("Could not open file for writing: " + filename);

    ply_file.write(out, binary);
}

template <typename F>
IsosurfaceMesh as_mesh(const F &b, const std::vector<float> &vertices,
                       const std::vector<uint32_t> &indices,
                       const std::vector<float> &normals) {

    IsosurfaceMesh result;

    result.vertices.resize(vertices.size());
    result.normals.resize(vertices.size());
    result.faces.resize(indices.size());


    float length = b.side_length();
    const auto &origin = b.origin();
    for (size_t i = 0; i < vertices.size(); i += 3) {
        result.vertices[i] = occ::units::BOHR_TO_ANGSTROM * (vertices[i] * length + origin(0));
        result.vertices[i + 1] = occ::units::BOHR_TO_ANGSTROM * (vertices[i + 1] * length + origin(1));
        result.vertices[i + 2] = occ::units::BOHR_TO_ANGSTROM * (vertices[i + 2] * length + origin(2));

        Eigen::Vector3f normal = Eigen::Vector3f(normals[i], normals[i + 1], normals[i + 2]);
	normal.normalize();
	result.normals[i] = normal(0);
	result.normals[i + 1] = normal(1);
	result.normals[i + 2] = normal(2);
    }

    // winding is backward for some reason out of the marching cubes.
    for(size_t i = 0; i < indices.size(); i += 3) {
	result.faces[i] = indices[i];
	result.faces[i + 1] = indices[i + 2];
	result.faces[i + 2] = indices[i + 1];
    }

    return result;
}

template <typename F> IsosurfaceMesh extract_surface(F &func) {
    occ::timing::StopWatch sw;
    size_t cubes = func.cubes_per_side();
    auto mc = occ::geometry::mc::MarchingCubes(cubes);

    std::vector<float> vertices;
    std::vector<float> normals;
    std::vector<uint32_t> faces;
    sw.start();
    mc.extract_with_normals(func, vertices, faces, normals);
    sw.stop();
    occ::log::debug("Required {} function calls ", func.num_calls());
    occ::log::info("Surface extraction took {:.5f} s", sw.read());

    occ::log::info("Surface has {} vertices, {} faces", vertices.size() / 3,
                   faces.size() / 3);
    return as_mesh(func, vertices, faces, normals);
}

VertexProperties compute_surface_properties(const Molecule &m1,
                                            const Molecule &m2,
                                            Eigen::Ref<const Eigen::Matrix3Xf> vertices) {
    Eigen::Matrix3Xf inside = m1.positions().cast<float>();
    Eigen::Matrix3Xf outside = m2.positions().cast<float>();
    Eigen::VectorXf vdw_inside = m1.vdw_radii().cast<float>();
    Eigen::VectorXf vdw_outside = m2.vdw_radii().cast<float>();

    VertexProperties properties;
    int nthreads = occ::parallel::get_num_threads();

    occ::core::KDTree<float> interior_tree(inside.rows(), inside,
                                           occ::core::max_leaf);
    interior_tree.index->buildIndex();

    occ::core::KDTree<float> exterior_tree(outside.rows(), outside,
                                           occ::core::max_leaf);
    exterior_tree.index->buildIndex();

    occ::log::info("Indexes built");
    constexpr size_t num_results = 6;
    const size_t N = vertices.cols();

    std::vector<float> di(N), de(N), di_norm(N), de_norm(N), dnorm(N);
    std::vector<int> di_idx(N), de_idx(N), di_norm_idx(N), de_norm_idx(N);

    auto fill_properties = [&](int thread_id) {
        std::vector<size_t> indices(num_results);
        std::vector<float> dist_sq(num_results);
        std::vector<float> dist_norm(num_results);

        for (int i = 0; i < vertices.cols(); i++) {
            if (i % nthreads != thread_id)
                continue;

            Eigen::Vector3f v = vertices.col(i);
            {

                float dist_inside_norm = std::numeric_limits<float>::max();
                nanoflann::KNNResultSet<float> results(num_results);
                results.init(&indices[0], &dist_sq[0]);
                bool populated = interior_tree.index->findNeighbors(
                    results, v.data(), nanoflann::SearchParams());
                di[i] = std::sqrt(dist_sq[0]);
                di_idx[i] = indices[0];

                size_t inside_idx = 0;
                for (int idx = 0; idx < results.size(); idx++) {

                    float vdw = vdw_inside(indices[idx]);
                    float dnorm = (std::sqrt(dist_sq[idx]) - vdw) / vdw;

                    if (dnorm < dist_inside_norm) {
                        inside_idx = indices[idx];
                        dist_inside_norm = dnorm;
                    }
                }
                di_norm[i] = dist_inside_norm;
                di_norm_idx[i] = inside_idx;
            }

            {
                float dist_outside_norm = std::numeric_limits<float>::max();
                nanoflann::KNNResultSet<float> results(num_results);
                results.init(&indices[0], &dist_sq[0]);
                bool populated = exterior_tree.index->findNeighbors(
                    results, v.data(), nanoflann::SearchParams());
                de[i] = std::sqrt(dist_sq[0]);
                de_idx[i] = indices[0];

                size_t outside_idx = 0;
                for (int idx = 0; idx < results.size(); idx++) {

                    float vdw = vdw_outside(indices[idx]);
                    float dnorm = (std::sqrt(dist_sq[idx]) - vdw) / vdw;

                    if (dnorm < dist_outside_norm) {
                        outside_idx = indices[idx];
                        dist_outside_norm = dnorm;
                    }
                }
                de_norm[i] = dist_outside_norm;
                de_norm_idx[i] = outside_idx;
            }

            dnorm[i] = de_norm[i] + di_norm[i];
        }
    };

    occ::timing::start(occ::timing::category::isosurface_properties);
    occ::parallel::parallel_do(fill_properties);
    occ::timing::stop(occ::timing::category::isosurface_properties);

    properties.add_property("di", di);
    properties.add_property("di_idx", di_idx);
    properties.add_property("de", de);
    properties.add_property("de_idx", de_idx);
    properties.add_property("di_norm", di_norm);
    properties.add_property("di_norm_idx", di_norm_idx);
    properties.add_property("de_norm", de_norm);
    properties.add_property("de_norm_idx", de_norm_idx);
    properties.add_property("dnorm", dnorm);

    return properties;
}

namespace occ::main {

CLI::App *add_isosurface_subcommand(CLI::App &app) {
    CLI::App *iso =
        app.add_subcommand("isosurface", "compute molecular isosurfaces");
    auto config = std::make_shared<IsosurfaceConfig>();

    iso->add_option("geometry", config->geometry_filename,
                    "input geometry file (xyz)")
        ->required();

    iso->add_option("environment", config->environment_filename,
                    "environment geometry file (xyz)");

    iso->add_option("--kind", config->kind,
                    "surface kind");

    iso->add_flag("--binary,!--ascii", config->binary_output, "Write binary/ascii file format (default binary)");

    iso->add_option("--max-depth", config->max_depth, "Maximum voxel depth");
    iso->add_option("--separation", config->separation,
                    "targt voxel separation");
    iso->add_option("--isovalue", config->isovalue, "target isovalue");
    iso->add_option("--background-density", config->background_density,
                    "add background density to close surface");

    iso->add_option("--output,-o", config->output_filename,
                    "destination to write file");

    iso->fallthrough();
    iso->callback([config]() { run_isosurface_subcommand(*config); });
    return iso;
}

void run_isosurface_subcommand(IsosurfaceConfig const &config) {
    IsosurfaceMesh mesh;
    VertexProperties properties;

    if(occ::qm::Wavefunction::is_likely_wavefunction_filename(config.geometry_filename)) {
	if(config.kind == "esp") {
	    auto wfn = occ::qm::Wavefunction::load(config.geometry_filename);
	    auto func = ElectricPotentialFunctor(wfn, config.separation * occ::units::ANGSTROM_TO_BOHR);
	    func.set_isovalue(config.isovalue);
	    mesh = extract_surface(func);
	}
	else {
	    auto wfn = occ::qm::Wavefunction::load(config.geometry_filename);
	    auto func = ElectronDensityFunctor(wfn, config.separation * occ::units::ANGSTROM_TO_BOHR);
	    func.set_isovalue(config.isovalue);
	    mesh = extract_surface(func);
	}
    }
    else if (config.kind == "hirshfeld") {
	if(config.environment_filename.empty()) throw std::runtime_error("Hirshfeld surface requires exterior region");

        Molecule m1 = occ::io::molecule_from_xyz_file(config.geometry_filename);
        Molecule m2 =
            occ::io::molecule_from_xyz_file(config.environment_filename);

        occ::log::info("Interior region has {} atoms", m1.size());
        occ::log::info("Exterior region has {} atoms", m2.size());

        auto func = StockholderWeightFunctor(
            m1, m2, config.separation * occ::units::ANGSTROM_TO_BOHR);
        func.set_background_density(config.background_density);
	mesh = extract_surface(func);
	
        properties = compute_surface_properties(m1, m2, Eigen::Map<const Eigen::Matrix3Xf>(mesh.vertices.data(), 3, mesh.vertices.size() / 3));
    } else {
        Molecule m1 = occ::io::molecule_from_xyz_file(config.geometry_filename);
        occ::log::info("Interior region has {} atoms", m1.size());

        auto func = PromoleculeDensityFunctor(
            m1, config.separation * occ::units::ANGSTROM_TO_BOHR);
        func.set_isovalue(config.isovalue);
	mesh = extract_surface(func);

	if(!config.environment_filename.empty()) {
	    Molecule m2 =
		occ::io::molecule_from_xyz_file(config.environment_filename);
	    properties = compute_surface_properties(m1, m2, Eigen::Map<const Eigen::Matrix3Xf>(mesh.vertices.data(), 3, mesh.vertices.size() / 3));
	}
    }
    Eigen::Map<const Eigen::Matrix3Xf> verts(mesh.vertices.data(), 3, mesh.vertices.size() / 3);
    Eigen::Vector3f lower_left = verts.rowwise().minCoeff();
    Eigen::Vector3f upper_right = verts.rowwise().maxCoeff();
    occ::log::info("Lower corner of mesh: [{:.3f} {:.3f} {:.3f}]",
                   lower_left(0), lower_left(1), lower_left(2));
    occ::log::info("Upper corner of mesh: [{:.3f} {:.3f} {:.3f}]",
                   upper_right(0), upper_right(1), upper_right(2));

    occ::log::info("Writing surface to {}", config.output_filename);
    write_mesh_file(config.output_filename, mesh, properties, config.binary_output);
}

} // namespace occ::main
